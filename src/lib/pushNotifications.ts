'use client'

export interface PushNotificationOptions {
  title: string
  body: string
  icon?: string
  badge?: string
  data?: any
  requireInteraction?: boolean
  silent?: boolean
}

export class PushNotificationManager {
  private static instance: PushNotificationManager
  private registration: ServiceWorkerRegistration | null = null
  private subscription: PushSubscription | null = null

  private constructor() {}

  static getInstance(): PushNotificationManager {
    if (!PushNotificationManager.instance) {
      PushNotificationManager.instance = new PushNotificationManager()
    }
    return PushNotificationManager.instance
  }

  async initialize(deviceId: string): Promise<boolean> {
    try {
      console.log('üîß Initializing push notifications for device:', deviceId)
      console.log('Browser support check:', {
        serviceWorker: 'serviceWorker' in navigator,
        pushManager: 'PushManager' in window,
        notification: 'Notification' in window
      })

      if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        console.warn('‚ùå Push notifications not supported by this browser')
        return false
      }

      // Use the new ensureServiceWorkerRegistration method
      const registrationSuccess = await this.ensureServiceWorkerRegistration(deviceId)
      
      if (registrationSuccess) {
        console.log('‚úÖ Push notifications initialized successfully')
        console.log('Service worker scope:', this.registration?.scope)
        return true
      } else {
        console.error('‚ùå Push notifications initialization failed')
        return false
      }
    } catch (error) {
      console.error('‚ùå Failed to initialize push notifications:', error)
      console.error('Initialize error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined
      })
      return false
    }
  }

  async requestPermission(deviceId: string): Promise<boolean> {
    try {
      console.log('üîî requestPermission called with deviceId:', deviceId)
      console.log('Current permission status:', Notification.permission)

      if (Notification.permission === 'granted') {
        console.log('‚úÖ Permission already granted, subscribing to push...')
        return await this.subscribeToPush(deviceId)
      }

      if (Notification.permission === 'denied') {
        console.warn('‚ùå Push notifications are blocked by user')
        return false
      }

      // Request permission
      console.log('üìù Requesting notification permission...')
      const permission = await Notification.requestPermission()
      console.log('üìã Permission request result:', permission)
      
      if (permission === 'granted') {
        console.log('‚úÖ Permission granted, subscribing to push...')
        return await this.subscribeToPush(deviceId)
      } else {
        console.warn('‚ùå Permission denied by user:', permission)
        return false
      }
    } catch (error) {
      console.error('‚ùå Failed to request notification permission:', error)
      console.error('Permission request error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined
      })
      return false
    }
  }

  private async subscribeToPush(deviceId: string): Promise<boolean> {
    try {
      console.log('üöÄ Starting push subscription process...')
      console.log('Device ID:', deviceId)
      console.log('Service worker registration state:', {
        hasRegistration: !!this.registration,
        isActive: !!this.registration?.active,
        hasPushManager: !!this.registration?.pushManager,
        state: this.registration?.active?.state,
        scope: this.registration?.scope
      })

      if (!this.registration) {
        console.error('‚ùå Service worker not registered')
        throw new Error('Service worker not registered')
      }

      if (!this.registration.active) {
        console.error('‚ùå Service worker not active')
        throw new Error('Service worker registration exists but worker is not active')
      }

      // Check if push manager is available
      if (!this.registration.pushManager) {
        console.error('‚ùå Push manager not available')
        throw new Error('Push manager not available')
      }

      console.log('‚úÖ Service worker validation passed')

      // VAPID public key - in production, this would come from environment variables
      const vapidPublicKey = 'BAqmyckLdT9Rk2EVrzi_P4-QzF89uoFIlzOsscQXhCgBEDDbelZLbQFM1x4a2BBn8ac6dxFo3d5TrmSzy9_eFR8'
      console.log('üîë Using VAPID public key:', vapidPublicKey.substring(0, 20) + '...')
      
      console.log('üìù Creating push subscription...')
      const subscription = await this.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(vapidPublicKey)
      })

      console.log('‚úÖ Push subscription created successfully')
      console.log('Subscription endpoint:', subscription.endpoint.substring(0, 50) + '...')
      
      this.subscription = subscription

      // Save subscription to database via API
      console.log('üíæ Saving subscription to database...')
      try {
        const subscriptionData = {
          deviceId,
          subscription: subscription.toJSON()
        }
        console.log('Subscription data:', {
          deviceId: subscriptionData.deviceId,
          endpoint: subscriptionData.subscription.endpoint?.substring(0, 50) + '...',
          hasKeys: !!(subscriptionData.subscription.keys?.p256dh && subscriptionData.subscription.keys?.auth)
        })

        const response = await fetch('/api/customers/subscriptions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(subscriptionData)
        })

        console.log('üì° API response status:', response.status)

        if (response.ok) {
          const responseData = await response.json()
          console.log('‚úÖ Push subscription saved successfully:', responseData)
          return true
        } else {
          const errorText = await response.text()
          console.error('‚ùå Failed to save push subscription - HTTP', response.status)
          console.error('Response body:', errorText)
          try {
            const errorJson = JSON.parse(errorText)
            console.error('Parsed error:', errorJson)
          } catch (e) {
            console.error('Could not parse error response as JSON')
          }
          return false
        }
      } catch (apiError) {
        console.error('‚ùå API call failed:', apiError)
        console.error('API error details:', {
          message: apiError instanceof Error ? apiError.message : 'Unknown error',
          stack: apiError instanceof Error ? apiError.stack : undefined,
          name: apiError instanceof Error ? apiError.name : undefined
        })
        return false
      }
    } catch (error) {
      console.error('‚ùå Failed to subscribe to push notifications:', error)
      console.error('Subscribe error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined
      })
      return false
    }
  }

  async unsubscribe(deviceId: string): Promise<boolean> {
    try {
      if (!this.subscription) {
        return true
      }

      await this.subscription.unsubscribe()
      this.subscription = null

      // Remove from database via API
      try {
        await fetch(`/api/customers/subscriptions?deviceId=${encodeURIComponent(deviceId)}`, {
          method: 'DELETE'
        })
        console.log('üîî Unsubscribed from push notifications')
      } catch (error) {
        console.error('Failed to remove subscription from database:', error)
      }
      return true
    } catch (error) {
      console.error('Failed to unsubscribe from push notifications:', error)
      return false
    }
  }

  async forceResubscribe(deviceId: string): Promise<boolean> {
    try {
      console.log('üîÑ Starting force resubscribe process for device:', deviceId)
      
      // Step 1: Clear existing push subscription (but keep service worker)
      console.log('üóëÔ∏è Clearing existing push subscription...')
      try {
        if (this.subscription) {
          console.log('üßπ Unsubscribing current subscription...')
          await this.subscription.unsubscribe()
          this.subscription = null
        }
        
        // Clear any cached subscription from push manager (without affecting service worker)
        if (this.registration?.pushManager) {
          const existingSubscription = await this.registration.pushManager.getSubscription()
          if (existingSubscription) {
            console.log('üßπ Unsubscribing existing browser subscription...')
            await existingSubscription.unsubscribe()
          }
        }
        
        // Remove from database
        await fetch(`/api/customers/subscriptions?deviceId=${encodeURIComponent(deviceId)}`, {
          method: 'DELETE'
        })
        console.log('üóëÔ∏è Cleared subscription from database')
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to clear existing subscriptions:', error)
      }
      
      // Step 2: Ensure service worker is properly registered and ready
      console.log('üîß Verifying service worker registration...')
      await this.ensureServiceWorkerRegistration(deviceId)
      
      if (!this.registration) {
        throw new Error('Service worker registration failed during force resubscribe')
      }
      
      // Step 3: Wait a moment for cleanup and registration to stabilize
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      // Step 4: Create fresh push subscription
      console.log('üÜï Creating fresh push subscription...')
      const success = await this.subscribeToPush(deviceId)
      
      if (success) {
        console.log('‚úÖ Force resubscribe completed successfully')
        return true
      } else {
        console.error('‚ùå Force resubscribe failed during subscription creation')
        return false
      }
    } catch (error) {
      console.error('‚ùå Force resubscribe failed:', error)
      console.error('Force resubscribe error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined
      })
      return false
    }
  }

  private async ensureServiceWorkerRegistration(deviceId: string): Promise<boolean> {
    try {
      console.log('üîç Checking service worker registration state...')
      
      // Check if we already have a valid registration
      if (this.registration && this.registration.active) {
        console.log('‚úÖ Service worker already registered and active')
        return true
      }
      
      // Try to get existing registration (getRegistration takes scope, not script path)
      const existingRegistration = await navigator.serviceWorker.getRegistration('/')
      if (existingRegistration && existingRegistration.active) {
        console.log('‚úÖ Found existing service worker registration')
        console.log('Existing registration details:', {
          scope: existingRegistration.scope,
          state: existingRegistration.active.state,
          scriptURL: existingRegistration.active.scriptURL
        })
        this.registration = existingRegistration
        return true
      }
      
      // Re-register service worker if needed
      console.log('üìù Re-registering service worker...')
      this.registration = await navigator.serviceWorker.register('/sw.js')
      
      // Wait for service worker to be ready
      console.log('‚è≥ Waiting for service worker to be ready...')
      await navigator.serviceWorker.ready
      
      if (this.registration.active) {
        console.log('‚úÖ Service worker registered and ready')
        return true
      } else {
        throw new Error('Service worker registration succeeded but worker is not active')
      }
    } catch (error) {
      console.error('‚ùå Service worker registration failed:', error)
      console.error('SW registration error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined,
        swSupported: 'serviceWorker' in navigator,
        swReady: navigator.serviceWorker ? 'ready method exists' : 'no ready method'
      })
      return false
    }
  }

  isSupported(): boolean {
    return 'serviceWorker' in navigator && 'PushManager' in window && 'Notification' in window
  }

  getPermissionStatus(): NotificationPermission {
    return Notification.permission
  }

  async getSubscription(): Promise<PushSubscription | null> {
    if (!this.registration) {
      return null
    }

    try {
      return await this.registration.pushManager.getSubscription()
    } catch (error) {
      console.error('Failed to get subscription:', error)
      return null
    }
  }

  private urlBase64ToUint8Array(base64String: string): Uint8Array {
    const padding = '='.repeat((4 - base64String.length % 4) % 4)
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/')

    const rawData = window.atob(base64)
    const outputArray = new Uint8Array(rawData.length)

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i)
    }
    return outputArray
  }

  // Test notification (for development)
  async sendTestNotification(): Promise<void> {
    try {
      console.log('üß™ Testing notification...')
      console.log('üîî Notification permission:', Notification.permission)
      
      if (!('Notification' in window)) {
        console.error('‚ùå Browser does not support notifications')
        alert('Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÏïåÎ¶ºÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.')
        return
      }

      if (Notification.permission === 'granted') {
        console.log('‚úÖ Creating test notification...')
        const notification = new Notification('Îã®Í≥® V2 ÌÖåÏä§Ìä∏', {
          body: 'Ìë∏Ïãú ÏïåÎ¶ºÏù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌï©ÎãàÎã§!',
          icon: '/icon-192x192.png',
          badge: '/badge-72x72.png'
        })
        
        notification.onclick = () => {
          console.log('üñ±Ô∏è Test notification clicked')
          notification.close()
        }
        
        notification.onshow = () => {
          console.log('‚úÖ Test notification displayed')
        }
        
        notification.onerror = (error) => {
          console.error('‚ùå Test notification error:', error)
        }
        
        console.log('üéâ Test notification created successfully')
      } else {
        console.warn('‚ö†Ô∏è Notification permission not granted:', Notification.permission)
        alert(`ÏïåÎ¶º Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. ÌòÑÏû¨ ÏÉÅÌÉú: ${Notification.permission}`)
      }
    } catch (error) {
      console.error('‚ùå sendTestNotification error:', error)
      alert('ÏïåÎ¶º ÌÖåÏä§Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + (error instanceof Error ? error.message : 'Unknown error'))
    }
  }
}

// Korean text constants for permission requests
export const KOREAN_TEXT = {
  PERMISSION_TITLE: 'ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠',
  PERMISSION_BODY: 'ÏÉàÎ°úÏö¥ Ìï†Ïù∏ Ï†ïÎ≥¥ÏôÄ ÌäπÎ≥Ñ ÌòúÌÉùÏùÑ ÎÜìÏπòÏßÄ ÎßàÏÑ∏Ïöî! Ìë∏Ïãú ÏïåÎ¶ºÏùÑ ÌóàÏö©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
  PERMISSION_ALLOW: 'ÏïåÎ¶º ÌóàÏö©',
  PERMISSION_DENY: 'ÎÇòÏ§ëÏóê',
  NOTIFICATION_BLOCKED: 'ÏïåÎ¶ºÏù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§',
  NOTIFICATION_BLOCKED_HELP: 'Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÏïåÎ¶ºÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.',
  NOTIFICATION_SUCCESS: 'ÏïåÎ¶ºÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§',
  NOTIFICATION_SUCCESS_HELP: 'Ïù¥Ï†ú ÏÉàÎ°úÏö¥ Ìï†Ïù∏ Ï†ïÎ≥¥Î•º Î∞õÏïÑÎ≥¥Ïã§ Ïàò ÏûàÏäµÎãàÎã§.',
  NOTIFICATION_ERROR: 'ÏïåÎ¶º ÏÑ§Ï†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
  NOTIFICATION_ERROR_HELP: 'Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
  RESUBSCRIBE_SUCCESS: 'ÏÉà ÏïåÎ¶º Îì±Î°ùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§',
  RESUBSCRIBE_SUCCESS_HELP: 'ÏÉàÎ°úÏö¥ FCM ÌÜ†ÌÅ∞ÏúºÎ°ú ÏïåÎ¶ºÏùÑ Î∞õÏùÑ Ïàò ÏûàÏäµÎãàÎã§.',
  RESUBSCRIBE_ERROR: 'ÏÉà ÏïåÎ¶º Îì±Î°ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
  RESUBSCRIBE_ERROR_HELP: 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
  NEW_DEAL_TITLE: 'ÏÉàÎ°úÏö¥ Ìï†Ïù∏!',
  DEAL_NEARBY_TITLE: 'Í∑ºÏ≤ò Ìï†Ïù∏ Ï†ïÎ≥¥',
  DEAL_EXPIRES_SOON: 'Í≥ß ÎßàÍ∞êÎêòÎäî Ìï†Ïù∏',
}

export default PushNotificationManager